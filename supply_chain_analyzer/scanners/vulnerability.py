"""Vulnerability scanner using OSV database."""

import httpx
from typing import Optional
from datetime import datetime

from ..core.config import Config
from ..core.models import Dependency, Vulnerability, Severity


class VulnerabilityScanner:
    """Scanner for known vulnerabilities using OSV (Open Source Vulnerabilities) database."""
    
    OSV_API_URL = "https://api.osv.dev/v1/query"
    OSV_BATCH_URL = "https://api.osv.dev/v1/querybatch"
    
    def __init__(self, config: Config):
        """Initialize the vulnerability scanner."""
        self.config = config
        self._client = httpx.Client(timeout=config.timeout_seconds)
    
    def scan(self, dependencies: list[Dependency]) -> dict[str, list[Vulnerability]]:
        """
        Scan dependencies for known vulnerabilities.
        
        Args:
            dependencies: List of dependencies to scan
            
        Returns:
            Dictionary mapping dependency identifiers to vulnerability lists
        """
        results: dict[str, list[Vulnerability]] = {}
        
        for dep in dependencies:
            vulns = self._query_osv(dep)
            if vulns:
                results[dep.identifier] = vulns
        
        return results
    
    def _query_osv(self, dependency: Dependency) -> list[Vulnerability]:
        """Query OSV API for vulnerabilities affecting a dependency."""
        try:
            payload = {
                "package": {
                    "name": dependency.name,
                    "ecosystem": "PyPI",  # OSV uses PyPI for pip packages
                },
            }
            
            # Add version if available and not a wildcard
            if dependency.version and dependency.version != "*":
                payload["version"] = dependency.version
            
            response = self._client.post(self.OSV_API_URL, json=payload)
            response.raise_for_status()
            
            data = response.json()
            vulns = data.get("vulns", [])
            
            return [self._parse_osv_vuln(v) for v in vulns]
            
        except httpx.HTTPError:
            # Log error but don't fail the scan
            return []
        except Exception:
            return []
    
    def _parse_osv_vuln(self, osv_data: dict) -> Vulnerability:
        """Parse an OSV vulnerability response into our model."""
        vuln_id = osv_data.get("id", "UNKNOWN")
        
        # Get severity from CVSS if available
        severity = Severity.UNKNOWN
        cvss_score = None
        
        for severity_entry in osv_data.get("severity", []):
            if severity_entry.get("type") == "CVSS_V3":
                score_str = severity_entry.get("score", "")
                try:
                    # CVSS string format: "CVSS:3.1/AV:N/AC:L/..."
                    # We need to calculate or extract the score
                    cvss_score = self._extract_cvss_score(score_str)
                    severity = Severity.from_cvss(cvss_score)
                except Exception:
                    pass
        
        # If no CVSS, try database_specific severity
        if severity == Severity.UNKNOWN:
            db_severity = osv_data.get("database_specific", {}).get("severity", "").upper()
            if db_severity in ("CRITICAL", "HIGH", "MEDIUM", "LOW"):
                severity = Severity[db_severity]
        
        # Extract affected versions
        affected_versions = []
        fixed_versions = []
        for affected in osv_data.get("affected", []):
            for version_range in affected.get("ranges", []):
                for event in version_range.get("events", []):
                    if "introduced" in event:
                        affected_versions.append(f">={event['introduced']}")
                    if "fixed" in event:
                        fixed_versions.append(event["fixed"])
        
        # Parse published date
        published = None
        if "published" in osv_data:
            try:
                published = datetime.fromisoformat(osv_data["published"].replace("Z", "+00:00"))
            except Exception:
                pass
        
        return Vulnerability(
            id=vuln_id,
            summary=osv_data.get("summary", "No summary available"),
            description=osv_data.get("details", ""),
            severity=severity,
            cvss_score=cvss_score,
            affected_versions=affected_versions,
            fixed_versions=fixed_versions,
            references=[ref.get("url", "") for ref in osv_data.get("references", [])],
            published=published,
        )
    
    def _extract_cvss_score(self, cvss_string: str) -> float:
        """Extract a numeric CVSS score from a CVSS vector string."""
        # This is a simplified extraction - in production you'd use a CVSS library
        # For now, return a reasonable default based on common patterns
        if "AV:N" in cvss_string and "AC:L" in cvss_string:
            return 7.5  # Network accessible, low complexity = likely high
        elif "AV:N" in cvss_string:
            return 6.0
        elif "AV:L" in cvss_string:
            return 4.0
        return 5.0  # Default medium
    
    def __del__(self):
        """Cleanup HTTP client."""
        if hasattr(self, "_client"):
            self._client.close()
